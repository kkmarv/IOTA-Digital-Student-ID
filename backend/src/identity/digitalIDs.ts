import cfg from '../config.js'
import {
  Account,
  AccountBuilder,
  Credential,
  DID,
  IdentitySetup,
  Issuer,
  MethodContent,
  Presentation,
  ProofOptions,
  ProofPurpose,
  Timestamp
} from '@iota/identity-wasm/node/identity_wasm.js'
import { IMatriculationData, ServiceType } from './types.js'
import { MatriculationVC } from './verifiable/credentials.js'
import { MatriculationVP } from './verifiable/presentations.js'


/**
 * A `DigitalID` represents an identity with its own {@link Document}.
 * It offers high-level access to the IOTA Tangle, and
 * it is able to store its own secret keys through the {@link Account} and {@link Storage} API respectively.
 */
abstract class DigitalID {
  protected static readonly builder = new AccountBuilder(cfg.iota.accBuilder)
  readonly account: Account

  protected constructor(account: Account) {
    this.account = account
    console.log(this.toString());

    // this.verifySelf() TODO can do when published to tangle
  }

  /**
   * Serialize the {@link Document} of this {@link DigitalID} as a {@link JSON} object.
   */
  toJSON() {
    return this.account.document().toJSON()
  }

  /**
   * Return a `string` representation of this account.
   */
  toString(): string {
    return JSON.stringify(this.toJSON(), null, 2)
  }

  /**
   * Verify that the {@link Document}'s signature was generated by a valid method. Also verify its syntax.
   */
  verifySelf(): void {
    this.account.document().verifyDocument(this.account.document())
  }
}


/**
 * A manager for a student's {@link DID} {@link Document} that manages private keys and access to the Tangle.
 */
export class StudentID extends DigitalID {
  private static readonly matriculationFragment = '#sign-vp-matriculation'

  private constructor(account: Account) {
    super(account)
  }

  /**
   * Create a Verifiable {@link Presentation} to present the matriculation status of this `StudentID`.
   * @param credential The credentials to include in this Verifiable Presentation.
   * @param challenge The challenge to include in this Verifiable Presentation as a proof of authentication.
   * Typically issued by an {@link Issuer}.
   * @returns A newly created {@link MatriculationVP} signed by this student.
   */
  async newSignedMatriculationVP(credential: MatriculationVC, challenge: string): Promise<Presentation> {
    return this.account.createSignedPresentation(
      StudentID.matriculationFragment,
      new MatriculationVP(this.account.did(), credential),
      new ProofOptions({
        created: Timestamp.nowUTC(),
        expires: Timestamp.nowUTC().checkedAdd(cfg.iota.proofDuration),
        challenge: challenge,
        domain: '', // TODO research
        purpose: ProofPurpose.authentication()
      })
    )
  }

  /**
   * Construct a new `StudentID`.
   * @param identitySetup Use a pre-generated Ed25519 private key for the {@link DID}.
   * @returns A new `StudentID`.
   */
  static async new(identitySetup?: IdentitySetup): Promise<StudentID> {
    const account = await DigitalID.builder.createIdentity(identitySetup)

    // Set the student's DID as the Document controller
    await account.setController({ controllers: account.did() })
    // Sign all changes made to the DID Document.
    await account.updateDocumentUnchecked(
      await account.createSignedDocument(
        account.document().defaultSigningMethod().id().fragment()!,
        account.document(),
        ProofOptions.default()
      )
    )
    return new StudentID(account)
  }

  /**
   * Load an existing `StudentID` from {@link Storage}.
   * @param did The {@link DID} of the `StudentID` to look for.
   * @returns An existing `StudentID`. Will throw an Error, if `did` cannot be found.
   */
  static async load(did: DID): Promise<StudentID> {
    return new StudentID(await DigitalID.builder.loadIdentity(did))
  }
}


/**
 * A manager for a university's {@link DID} {@link Document}
 * that manages private keys and access to the IOTA Tangle.
 */
export class UniversityID extends DigitalID implements Issuer {
  private static readonly homepageFragment = '#linked-domain-homepage'
  private static readonly matriculationFragment = '#sign-matriculation-vc'

  // Issuer objects are forced to have an ID of type string instead of DID (@v0.6.0 of @iota/identity-wasm)
  readonly id: string
  readonly [properties: string]: unknown;

  private constructor(account: Account) {
    super(account)
    this.id = account.document().id().toString()
  }

  /**
   * Issue a new Verifiable Credential, effectively matriculating a student at this university.
   * @param subject The student's registration data.
   * @param challenge Arbitrary text taken from the student to include in this credential. Used for improved security.
   * @returns A signed Verifiable Credential providing information about the student's matriculation status.
   */
  issueMatriculationVC(subject: IMatriculationData, challenge: string): Promise<Credential> {
    return this.account.createSignedCredential(
      UniversityID.matriculationFragment,
      new MatriculationVC(this, subject),
      new ProofOptions({
        created: Timestamp.nowUTC(),
        expires: Timestamp.nowUTC().checkedAdd(cfg.iota.proofDuration),
        challenge: challenge,
        domain: '', // TODO research
        purpose: ProofPurpose.authentication()
      })
    )
  }

  /**
   * Construct a new `UniversityID`.
   * @param name The official name of the university represented by this `UniversityID`.
   * @param homepage A URL identifying the university on the web, i.e. its homepage.
   * @param identitySetup Use a pre-generated Ed25519 private key for the {@link DID}.
   * @returns A new `UniversityID`.
   */
  static async new(name: string, homepage: string, identitySetup?: IdentitySetup): Promise<UniversityID> {
    const account = await DigitalID.builder.createIdentity(identitySetup)

    // Set the university's DID as the Document controller
    await account.setController({ controllers: account.did() })
    // Add a reference to the university's web presence.

    await account.createService({
      fragment: UniversityID.homepageFragment,
      type: ServiceType.LINKED_DOMAINS,
      endpoint: homepage
    })

    // Create signing method for matriculation issuance
    await account.createMethod({
      fragment: UniversityID.matriculationFragment,
      content: MethodContent.GenerateEd25519()
    })
    // Sign all changes made to the DID Document.
    await account.updateDocumentUnchecked(
      await account.createSignedDocument(
        account.document().defaultSigningMethod().id().fragment()!,
        account.document(),
        ProofOptions.default()
      )
    )
    return new UniversityID(account)
  }

  /**
   * Load an existing `UniversityID` from {@link Storage}.
   * @param did A string representing the {@link DID} of the `UniversityID` to look for.
   * @returns An existing `UniversityID`.
   * @throws `IdentityNotFound` if `did` cannot be found locally.
   */
  static async load(did: DID, name: string, homepage: string): Promise<UniversityID> {
    return new UniversityID(await DigitalID.builder.loadIdentity(did))
  }
}