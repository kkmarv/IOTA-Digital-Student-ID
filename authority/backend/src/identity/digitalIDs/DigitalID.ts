import identity from '@iota/identity-wasm/node'
import { accountBuilderConfig, clientConfig } from '../../../config'

/**
 * A `DigitalID` represents an identity with its own {@link Document}.
 * It offers high-level access to the IOTA Tangle, and
 * it is able to store its own secret keys through the {@link Account} and {@link Storage} API respectively.
 */
export abstract class DigitalID {
  protected static readonly builder = new identity.AccountBuilder(accountBuilderConfig)
  protected static resolver: identity.Resolver
  protected static readonly resolverBuilder = identity.Resolver.builder().clientConfig(clientConfig)

  readonly account: identity.Account

  protected constructor(account: identity.Account) {
    this.account = account
    // await account.publish() # TOTO remove this from subclasses and put here
    // this.verifySelf() TODO can do when published to tangle
  }

  /**
   * Fetch and return a {@link DID} {@link Document} from the Tangle.
   * @param did {@link DID} to resolve.
   * @returns The {@link DID}'s {@link document}.
   */
  static async resolve(did: identity.DID): Promise<identity.Document> {
    return (await DigitalID.resolver.resolve(did)).intoDocument()
  }

  /**
   * Decrypt a message that has been signed with a public key from this ID.
   * @param encryptedMessage The signature of the message
   * @param agreement
   * @returns
   */
  async decryptMessage(encryptedMessage: identity.EncryptedData, agreement: identity.AgreementInfo) {
    return await this.account.decryptData(
      encryptedMessage,
      identity.EncryptionAlgorithm.A256GCM(),
      identity.CekAlgorithm.EcdhEs(agreement),
      ''
    ) // TODO key fragment
  }

  /**
   * Serialize the {@link Document} of this {@link DigitalID} as a {@link JSON} object.
   */
  toJSON() {
    return this.account.document().toJSON()
  }

  /**
   * Return a `string` representation of this account.
   */
  toString(): string {
    return JSON.stringify(this.toJSON(), null, 2)
  }

  /**
   * Verify that the {@link Document}'s signature was generated by a valid method. Also verify its syntax.
   */
  verifySelf(): void {
    this.account.document().verifyDocument(this.account.document())
  }
}
